
# knitr document van Steensel lab

# Gene repression in LADs
## Christ Leemans, 03-11-2016 - to date

## Introduction
Generally speaking, genes inside lamina associated domains are not or very lowly expressed. These genes can either be actively repressed by their DNA context (e.g. heterochromatin, lamina association), or simply be inactive (because essential factors for expression are missing?). Yet another group of genes seem to evade gene repression in the context of lamina associated domains. In this report I would like to investigate what defines these 3 groups of genes and how they compare to genes outside of lamina associated domains.

## Description of Data.

gencode.sure.160617.rda: 
    file from Joris, received 17 June 2016. Promoter positions in this file are from Gencode. Contains SuRE, gro-cap and cage expression data as well as the number of tissues in which each promoter is expressed.


## libraries, paths and data prep

```{r, fig.width=10, fig.height=10}
library(reshape2)
library(rtracklayer)
library(ggplot2)
library(DESeq2)
library(gridExtra)
library(plyr)
library(scales)
library(Matrix)
library(grid)
library(glmnet)
library(rtfbs)
library(BSgenome)
library(BSgenome.Hsapiens.UCSC.hg19)
library(doMC)
registerDoMC(cores=10)
load('../raw_data/biomart.rdata')

## There was one promoter that was wrongly annotated
bm_p[bm_p$ensembl_transcript_id=='ENST00000357491','ensembl_gene_id' ] = 'ENSG00000196350'



## Did not want to go through the hassle of install complete TFBStools package, since it was
## complaining abount dependencies. And I only needed JASPAR motif parsing functionality.
## So I copied the function from TFBSTools.
## <<< copied from TFBSTools >>>
### -----------------------------------------------------------------
### readJASPARMatrix: read the jaspar format PFM in txt file
### "individual" format:
### >MA0001.1 AGL3
### A  [ 0  3 79 40 66 48 65 11 65  0 ]
### C  [94 75  4  3  1  2  5  2  3  3 ]
### G  [ 1  0  3  4  1  0  5  3 28 88 ]
### T  [ 2 19 11 50 29 47 22 81  1  6 ]
### "all" format: multiple "individual" matrices and seperated with a blank line
### Exported
.processJASPARText <- function(text){
  ID <- sub("^>", "", strsplit(text[1], "\t")[[1]][1])
  name <- strsplit(text[1], "\t")[[1]][2]
  if(!identical(substr(text[2:5], 1, 1), DNA_BASES)){
    stop("The second to fifth lines of the file must start with",
         "`A`, `C`, `G`, `T`, respectively.")
  }
  profileMatrix <- do.call(rbind, strsplit(sub(" *]$", "", 
                                               sub("^(A|C|G|T)  \\[ *", "",
                                                   text[2:5])), " +"))
  mode(profileMatrix) <- "integer"
  rownames(profileMatrix) <- DNA_BASES
  ## changed the following part:
  # ans <- PFMatrix(ID=ID, name=name, profileMatrix=profileMatrix)
  pwm = log(t(profileMatrix)/colSums(profileMatrix))
  ans <- list(ID=ID, name=name, profileMatrix=pwm)
}

readJASPARMatrix <- function(fn, type=c("individual", "all")){
  type <- match.arg(type)
  text <- readLines(fn)
  if(type == "individual"){
    if(length(text) != 5L){
      stop("The `individual` format is supposed to have 5 lines!")
    }
    ans <- .processJASPARText(text)
  }else{
    if(length(text) %% 6 != 0L){
      stop("The `all` format is supposed to have a number of lines",
           "mutipled by 6!")
    }
    text2 <- split(text, rep(1:(length(text)/6), rep(6, length(text)/6)))
    ans <- lapply(text2, .processJASPARText)
    # ans <- do.call(PFMatrixList, ans)
  }
  return(ans)
}
## <<< end of copie >>>>


```


# MAIN

### SuRE data
Previously, Bas defined three different groups of promoters in LADs. The "escaper", "repressed" and "inactive" group. The "escaper" group contains promoters that are expressed in their endogenous LAD environment. The "repressed" group is inactive in the endogenous setting, but they do show autonomous promoter activity in SuRE data. The 'inactive' group shows neither endogenous expression nor autonomous promoter activity in SuRE data.

```{r, fig.width=10, fig.height=8}
load("../raw_data/gencode.sure.160617.rda")
Prom<-gencode.sure.160617; rm(gencode.sure.160617) #simpler name
#first re-calculate pseudocounts without jitter
P<-Prom[,c(1:8,23,20,26,28, 27)] #SuRE, GRO-cap, CAGE and LAD columns only
names(P)[9:13]<-c("SuRE", "GROcap", "CAGE", "LAD", 'tissues_expressed')


## for promoters and gene expression let's convert promoter transcript id's to gene id's
P$ensembl_transcript_id = do.call(rbind, strsplit(P$name, split='[.]'))[,1]

nrow(P) #orriginal number of rows
bm_match = match(P$ensembl_transcript_id, bm_p$ensembl_transcript_id)
P<-merge(P, bm_p, by="ensembl_transcript_id", all.x=TRUE)
nrow(P) #some double rows were introduced

P = P[match(Prom$name, P$name), ]

length(unique(P$ensembl_gene_id)) #number of unique genes

table(P[,c('strand.x','strand.y')]) #almost all strand listings are consistent

P<-P[, colnames(P)!='strand.y']
colnames(P)[colnames(P)=='strand.x'] = "strand"



## to be used by CGtools as the complete set of TSS's
peaks = data.frame(seqname=P$chr,
                   start=P$tss,
                   end=P$tss,
                   strand=P$strand)


Pseud<-min(P$SuRE[P$SuRE>0], na.rm=TRUE)/2
P$SuRE<-P$SuRE+Pseud
P$SuRE<-log10(P$SuRE)
PseudGro<-min(P$GROcap[P$GROcap>0], na.rm=TRUE)/2
P$GROcap<-P$GROcap+PseudGro
P$GROcap<-log10(P$GROcap)
PseudCage<-min(P$CAGE[P$CAGE>0], na.rm=TRUE)/2
P$CAGE<-P$CAGE+PseudCage
P$CAGE<-log10(P$CAGE)

#then calculate running mean for iLAD promoters:
P<-P[order(P$SuRE,sample(c(1:nrow(P)))),] #sort by SuRE and then random for ties
n<-60 #number of windows
w<-501 #window width (number of datapoints); if n*w > nrow(P) then windows overlap
s<-round(seq(from=w/2+0.0001, to=nrow(P)-w/2, length.out=n))
RM<-data.frame(SuRE.low=rep(NA,n), SuRE.mean=rep(NA,n), SuRE.hi=rep(NA,n), GROcap.lad=rep(NA,n), GROcap.ilad=rep(NA,n))
RM$SuRE.low=P$SuRE[s-floor(w/2)]
for(i in 1:n){RM$SuRE.mean[i]=mean(P$SuRE[(s[i]-floor(w/2)):(s[i]+floor(w/2))], na.rm=TRUE)}
RM$SuRE.hi=P$SuRE[s+floor(w/2)]
for(i in 1:n)
  {t<-P[(s[i]-floor(w/2)):(s[i]+floor(w/2)),]
   RM$GROcap.lad[i]<-mean(t$GROcap[t$LAD==1], na.rm=TRUE)
   RM$GROcap.ilad[i]<-mean(t$GROcap[t$LAD==0], na.rm=TRUE)
  }


#add first datapoint (SuRE equals pseudocount)
RM1<-RM[0,] #empty df
RM1[1,]<-c(rep(log10(Pseud),3), mean(P$GROcap[P$SuRE==log10(Pseud) & P$LAD==1]), mean(P$GROcap[P$SuRE==log10(Pseud) & P$LAD==0]))
RM<-rbind(RM1, RM)
rm(RM1)

#finally calculate LRS for all promoters:
P$LRS<- P$GROcap - approx(x=RM$SuRE.mean, y=RM$GROcap.ilad, xout=P$SuRE, rule=2)$y
#so the more negative the score, the more 'repressed' is the promoter by its chromatin/LAD context


#(arbitrary) cutoffs to define three groups of promoters:
INACT<- P$SuRE< -0.3 & P$LAD==1 & P$GROcap< -2 #inactive
NREP<- P$SuRE> 0 & P$LRS> -0.5 & P$LAD==1 & P$GROcap> -2 #not repressed
REP<- P$SuRE> 0.3 & P$LRS< -1 & P$LAD==1  & P$GROcap< -2 #repressed
Pcnts<-c(length(which(REP)), length(which(NREP)), length(which(INACT)))
names(Pcnts)<-c("repressed", "escaper", "inactive")
BND <- P$LAD==1 & !INACT & !NREP & !REP

#add class annotation column to P:
P$class<-NA
P$class[P$LAD==0]<-"iLAD"
P$class[INACT]<-"inactive"
P$class[NREP]<-"escaper"
P$class[REP]<-"repressed"
P$class[BND] <- "boundary"
P$class = factor(P$class, levels=c('iLAD', 'escaper', 'repressed', 'inactive', 'boundary'))

COLi<-"#00BBFF11" #dot color for iLAD promoters
COL_lad<-c("#FF0000", "#0077FF")
names(COL_lad)<-c('LAD', 'iLAD')

#color vector for plotting:
COL_class<-c("#A020F0", "#FFA500", "#006400", "#7e7e7e", "#0077FF")
names(COL_class)<-c("repressed", "escaper", "inactive", 'boundary', 'iLAD')

COL<-c("#A020F0", "#FFA500", "#006400")
names(COL)<-c("repressed", "escaper", "inactive")

class_names = paste0(levels(P$class), '; n=',table(P$class))
names(class_names) = levels(P$class)
P$class_n_prom = P$class
levels(P$class_n_prom) = class_names
COL_class_n_prom = COL_class[names(class_names)]
names(COL_class_n_prom) = class_names

lad_names = c(LAD=paste0('LAD; n=', table(P$LAD)['1']),
              iLAD=paste0('LAD; n=', table(P$LAD)['0']))
P$lad_n_prom = factor(ifelse(P$LAD==1, lad_names['LAD'], lad_names['iLAD']))
COL_lad_n = COL_lad
names(COL_lad_n) = lad_names


RM_melt = melt(RM, measure.vars=c('GROcap.ilad', 'GROcap.lad'))
RM_melt$variable = ifelse(RM_melt$variable=='GROcap.lad', lad_names['LAD'], lad_names['iLAD'])
ggplot(P, aes(x=SuRE, y=GROcap, color=lad_n_prom)) +
    geom_point(data=P[P$LAD==0, ], size=0.5, alpha=0.05) + 
    geom_point(data=P[P$LAD==1, ], size=0.5, alpha=0.2) + 
    theme_bw() +
    geom_line(data=RM_melt, aes(x=SuRE.mean, y=value, color=variable), size=1) +
    labs(y='log10(GROcap)', x='log10(SuRE)') +
    theme(legend.title=element_blank()) +
    scale_color_manual(values=COL_lad_n)
p_classes = P[which(P$class %in% c('inactive', 'escaper', 'repressed')),]
ggplot(P, aes(x=SuRE, y=GROcap)) + 
    geom_point(size=0.1,color=COLi) + 
    geom_point(data=p_classes, aes(color=class_n_prom), size=0.6) + 
    labs(y='log10(GROcap)', x='log10(SuRE)') +
    theme_bw() +
    geom_line(data=RM, aes(x=SuRE.mean, y=GROcap.ilad), color=COL_lad['iLAD']) +
    theme(legend.title=element_blank()) +
    scale_colour_manual(values=COL_class_n_prom) 

```

**conclusion:**

We now have a definition of 3 different groups. We can now look at what is different between these groups.

## create GRanges

```{r}
#genes as Granges object
gene_gr <-makeGRangesFromDataFrame(data.frame(seqnames=P$chr,
                                              start=P$txStart,
                                              end=P$txEnd,
                                              strand=P$strand,
                                              tss=P$tss),
                                              keep.extra.columns=TRUE)
names(gene_gr) = P$name
tss_gr = gene_gr
ranges(tss_gr) = IRanges(gene_gr$tss,
                         gene_gr$tss)


tss_up = 300
tss_down = 50
TSSR_gr = gene_gr
P_start = P$tss - ifelse(P$strand=='+',tss_down,tss_up)
P_start = ifelse(P_start<1,1,P_start)
P_end = P$tss + ifelse(P$strand=='+',tss_up,tss_down)
ranges(TSSR_gr) = IRanges(P_start, P_end)
names(TSSR_gr) = names(gene_gr)
export.bed(TSSR_gr, '../raw_data/tssr_300_50.bed')


tss_up = 1000
tss_down = 100
TSSR_gr = gene_gr
P_start = P$tss - ifelse(P$strand=='+',tss_down,tss_up)
P_start = ifelse(P_start<1,1,P_start)
P_end = P$tss + ifelse(P$strand=='+',tss_up,tss_down)
ranges(TSSR_gr) = IRanges(P_start, P_end)
names(TSSR_gr) = names(gene_gr)
export.bed(TSSR_gr, '../raw_data/tssr_1000_100.bed')
```

```{r}

count_rep1 = read.table('../raw_data/expression/K562_rep1ReadsPerGene.out.tab')
count_rep2 = read.table('../raw_data/expression/K562_rep2ReadsPerGene.out.tab')

count_table = cbind(count_rep1[,4], rep2=count_rep2[,4])
rownames(count_table) = count_rep1[,1]
colnames(count_table) = c('rep1', 'rep2')
exp = SummarizedExperiment(assays = list(counts=count_table[-(1:4), ]))
dds = DESeqDataSet(exp, design= ~ 1)
fpm = fpm(dds)
fpm = rowMeans(fpm)
fpm = log10(fpm + min(fpm[fpm!=0])/2)
g_match = match(P$ensembl_gene_id, names(fpm))
P$K562_fpm = NaN
P$K562_fpm[!is.na(g_match)] = fpm[g_match[!is.na(g_match)]]
```


```{r}

cpg_table = read.table('../raw_data/cpgIslandExtUnmasked.bed.gz', sep='\t',
                       stringsAsFactors=F)
colnames(cpg_table) = c('seqnames', 'start', 'end', 'name', 'length', 'cpgNum', 'gcNum', 'perCpg', 'perGC', 'obsExp')
cpg_ranges = makeGRangesFromDataFrame(cpg_table, keep.extra.columns= T)

o = findOverlaps(tss_gr, cpg_ranges, maxgap=500, ignore.strand=T)
o_frame = data.frame(o)
o_frame$score = cpg_ranges[subjectHits(o)]$cpgNum
o_frame$pos = start(tss_gr[queryHits(o)]) - start(cpg_ranges[subjectHits(o)])

maxCpG = ddply(o_frame, .(queryHits), function(x){
          if (nrow(x) > 1){
            result = x[which(x$score==max(x$score)),]
          } else {
            result = x[1,]
          }
          return(result)})


P$cpg_length = 0
P$cpg_length[maxCpG$queryHits] = cpg_ranges[maxCpG$subjectHits]$length
P$cpg_length = P$cpg_length + min(cpg_ranges[maxCpG$subjectHits]$length) / 2
P$cpg_num = 0
P$cpg_num[maxCpG$queryHits] = cpg_ranges[maxCpG$subjectHits]$cpgNum
P$cpg_num = P$cpg_num + min(cpg_ranges[maxCpG$subjectHits]$cpgNum) / 2

P$perGC = 0
P$perGC[maxCpG$queryHits] = cpg_ranges[maxCpG$subjectHits]$perGC
# P$perGC = P$perGC + min(cpg_ranges[maxCpG$subjectHits]$perGC) / 2
P$perCpg = 0
P$perCpg[maxCpG$queryHits] = cpg_ranges[maxCpG$subjectHits]$perCpg

P$obsExp = 0
P$obsExp[maxCpG$queryHits] = cpg_ranges[maxCpG$subjectHits]$obsExp

ggplot(P[P$class!='boundary', ] , aes(x=class, y=log2(cpg_num), color=class)) + 
    geom_violin(alpha=0.3) + 
    geom_point(data=P[P$class%in%names(COL), ],  position=position_jitter(width=0.5), alpha=0.3, size=0.3) +
    ylab('log2(number of CpG in island) (biggest island < 500b)') +
    scale_color_manual(values=COL_class)

ggplot(P[P$class!='boundary', ] , aes(x=class, y=perGC, color=class)) + 
    geom_violin(alpha=0.3) + 
    geom_point(data=P[P$class%in%names(COL), ],  position=position_jitter(width=0.5), alpha=0.3, size=0.3) +
    ylab('percentage of C and G in island (biggest island < 500b)') +
    scale_color_manual(values=COL_class)

ggplot(P[P$class!='boundary', ] , aes(x=class, y=log2(perCpg), color=class)) + 
    geom_violin(alpha=0.3) + 
    geom_point(data=P[P$class%in%names(COL), ],  position=position_jitter(width=0.5), alpha=0.3, size=0.3) +
    ylab('log2(percentage of CpG in island) (biggest island <500b)') +
    scale_color_manual(values=COL_class)

ggplot(P[P$class!='boundary', ] , aes(x=class, y=obsExp, color=class)) + 
    geom_violin(alpha=0.3) + 
    geom_point(data=P[P$class%in%names(COL), ],  position=position_jitter(width=0.5), alpha=0.3, size=0.3) +
    ylab('CpG island OE score (biggest island < 500b)') +
    scale_color_manual(values=COL_class)


ggplot(P[P$class!='boundary', ] , aes(x=class, y=log2(cpg_length), color=class)) + 
    geom_violin(alpha=0.3) + 
    geom_point(data=P[P$class%in%names(COL), ],  position=position_jitter(width=0.5), alpha=0.3, size=0.3) +
    ylab('log2(length CpG island) (biggest island < 500b)') +
    scale_color_manual(values=COL_class)
tss_gr$cpg_distance = mcols(distanceToNearest(tss_gr, cpg_ranges))$distance

P$cpg_class = NA
cpg_prom = P[which(tss_gr$cpg_distance < 1000), 'name']

non_cpg_prom = P[which(tss_gr$cpg_distance >= 1000), 'name']
P$cpg_class[P$name %in% cpg_prom] = 'CpG'
P$cpg_class[P$name %in% non_cpg_prom] = 'non_CpG'


```

```
bedtools getfasta -name \
                  -bed raw_data/tssr_300_50.bed \
                  -fi ~/data/hg19/genome.fa \
                  -fo raw_data/tssr_300_50.fa

AffinityProfile -sequence=raw_data/tssr_300_50.fa \
                -psam_list=$REDUCE_SUITE/data/PSAMs/Jaspar_2016.list \
                -output=raw_data/jaspar_affinity

AffinityProfile -sequence=raw_data/tssr_300_50.fa \
                -strand=2 \
                -psam_list=$REDUCE_SUITE/data/PSAMs/Jaspar_2016.list \
                -output=raw_data/jaspar_affinity

AffinityProfile -sequence=raw_data/tssr_300_50.fa \
                -strand=2 \
                -threshold=0.001 \
                -psam_list=$REDUCE_SUITE/data/PSAMs/Jaspar_2016.list \
                -output=raw_data/jaspar_affinity_0.001

AffinityProfile -sequence=raw_data/tssr_300_50.fa \
                -strand=2 \
                -threshold=0.05 \
                -psam_list=$REDUCE_SUITE/data/PSAMs/Jaspar_2016.list \
                -output=raw_data/jaspar_affinity_0.05

AffinityProfile -sequence=raw_data/tssr_300_50.fa \
                -psam_list=$REDUCE_SUITE/data/PSAMs/Cis-BP_2017.list \
                -output=raw_data/cis-bp_affinity
```

```r
library(biomaRt)
library(plyr)
tf_table = read.table('../raw_data/tf_table.txt', sep='\t', row.names=1)
colnames(tf_table) = c('name', 'species', 'class', 'family')

tf_translation = ddply(tf_table[,c('species','name')], .(name),
                       function(x){
                         symbol = gsub('[(]var.[0-9][)]','', x[,2])
                         cbind(x,symbol=unlist(strsplit(symbol, '::')))
                       })


humanMart = useMart(biomart = 'ensembl', dataset = 'hsapiens_gene_ensembl')
bm_eg = getBM(attributes=c('ensembl_gene_id','hgnc_symbol'),
              filters='hgnc_symbol', values=tf_translation$symbol, mart=humanMart)
tf_translation$gene_id = bm_eg[match(tf_translation$symbol, bm_eg$hgnc_symbol), 'ensembl_gene_id']

species = list(c('Mus musculus', 'mmusculus', 'mgi_symbol'),
               c('Rattus norvegicus', 'rnorvegicus', ''),
               c('Oryctolagus cuniculus', 'ocuniculus'), 
               c('Meleagris gallopavo', 'mgallopavo'), c('Gallus gallus', 'ggallus'))

translate <- function(species, dataset, symbol_name, translation_table){
  mart = useMart(biomart='ensembl', dataset=dataset)
  symbol_vec = translation_table$symbol[translation_table$species==species]
  bm_eg = getBM(attributes=c('ensembl_gene_id', symbol_name),
                filters=symbol_name, values=symbol_vec, mart=mart)
  bm_h = getBM(attributes=c('ensembl_gene_id', 'hsapiens_homolog_ensembl_gene',
                             'hsapiens_homolog_orthology_type', 'hsapiens_homolog_subtype',
                             'hsapiens_homolog_perc_id'),
                filters='ensembl_gene_id', values=bm_eg$ensembl_gene_id, mart=mart)
  bm_h = bm_h[bm_h$hsapiens_homolog_ensembl_gene!='', ]
  bm = ddply(bm_h, .(ensembl_gene_id), function(x, bm_eg){
    i = which(x$hsapiens_homolog_perc_id==max(x$hsapiens_homolog_perc_id))
    result = bm_eg[which(bm_eg$ensembl_gene_id==x$ensembl_gene_id[1]), ]
    result = c(result, hsapiens_gene_id=x[i,'hsapiens_homolog_ensembl_gene'])
    return(unlist(result))
  }, bm_eg=bm_eg)

  return(bm)
}

bm = translate('Mus musculus', 'mmusculus_gene_ensembl', 'mgi_symbol', tf_translation)
tf_match = match(bm$mgi_symbol, tf_translation$symbol)
tf_translation[tf_match[!is.na(tf_match)], 'gene_id'] = bm$hsapiens_gene_id[!is.na(tf_match)]

bm = translate('Rattus norvegicus', 'rnorvegicus_gene_ensembl', 'rgd_symbol', tf_translation)
tf_match = match(bm$rgd_symbol, tf_translation$symbol)
tf_translation[tf_match[!is.na(tf_match)], 'gene_id'] = bm$hsapiens_gene_id[!is.na(tf_match)]

bm = translate('Oryctolagus cuniculus', 'ocuniculus_gene_ensembl', 'hgnc_symbol', tf_translation)
tf_match = match(bm$hgnc_symbol, tf_translation$symbol)
tf_translation[tf_match[!is.na(tf_match)], 'gene_id'] = bm$hsapiens_gene_id[!is.na(tf_match)]

bm = translate('Meleagris gallopavo', 'mgallopavo_gene_ensembl', 'hgnc_symbol', tf_translation)
tf_match = match(bm$hgnc_symbol, tf_translation$symbol)
tf_translation[tf_match[!is.na(tf_match)], 'gene_id'] = bm$hsapiens_gene_id[!is.na(tf_match)]

bm = translate('Gallus gallus', 'ggallus_gene_ensembl', 'hgnc_symbol', tf_translation)
tf_match = match(bm$hgnc_symbol, tf_translation$symbol)
tf_translation[tf_match[!is.na(tf_match)], 'gene_id'] = bm$hsapiens_gene_id[!is.na(tf_match)]


write.table(tf_translation, file='../raw_data/tf_translation.txt')
```


```{r}

wilcox_affinity <- function(x_affinity, y_affinity, groups, tf_table, id_vec=NULL){
  if (is.null(id_vec)){
    id_vec = colnames(x_affinity)
  }  
  fit = mclapply(id_vec, function(id){
    x = x_affinity[,id]
    y = y_affinity[,id]
    mean = c(mean(x), mean(y))
    direction = groups[which(mean==max(mean))]
    if (length(direction) == 2){
      direction = 'unchanged'
    }
    median_fc = median(x) / median(y)
    mean_fc = mean[1] / mean[2]
    w = wilcox.test(x, y)
    return(list(w,direction, median_fc, mean_fc))
  })
  p_vec = unlist(lapply(fit, function(x){ x[[1]]$p.value}))
  p_adjust = p.adjust(p_vec, method='fdr')
  direction = lapply(fit, function(x){ x[[2]]})
  median_fc =  lapply(fit, function(x){ x[[3]]})
  mean_fc =  lapply(fit, function(x){ x[[4]]})
  result_table = cbind(id=id_vec, 
                       tf_table[id_vec, ],
                       direction=unlist(direction),
                       p_adjust = p_adjust,
                       median_fc = unlist(median_fc),
                       mean_fc = unlist(mean_fc))
  return(result_table)
}

tissues_expressed = read.table('../../../data/fantom/max_tissues_expressed.txt.gz',
                               sep='\t', header=T, stringsAsFactors=T)


# aff_table_cisbp = read.table('../raw_data/cis-bp_affinity/seq_psam.dat')
# colnames(aff_table_cisbp) = gsub('[.][0-9]+.xml','', colnames(aff_table_cisbp))
# tf_table_cisbp = read.table('../raw_data/CisBP_TF_Information.txt', sep='\t', fill=T,
#                       stringsAsFactors=F, header=T)

# tf_table_cisbp = unique(tf_table_cisbp[,c('Motif_ID', 'DBID', 'TF_Name', 'Family_Name')])
# tf_table_cisbp = tf_table_cisbp[tf_table_cisbp$Motif_ID!='.', ]
# tf_table_cisbp$Motif_ID = gsub('[.][0-9]+','', tf_table_cisbp$Motif_ID)
# tf_table_cisbp = tf_table_cisbp[grep('ENSG',tf_table_cisbp$DBID),]
# tf_table_cisbp$expression = fpm[tf_table_cisbp$DBID]
# tf_table_cisbp = tf_table_cisbp[match(unique(tf_table_cisbp$Motif_ID), tf_table_cisbp$Motif_ID), ]
# rownames(tf_table_cisbp) = tf_table_cisbp$Motif_ID
# tf_expressed = tf_table_cisbp[which(tf_table_cisbp$expression > 0), ]

# # id_vec = unique(tf_expressed$Motif_ID)
# id_vec = rownames(tf_table_cisbp)
# id_vec = id_vec[id_vec%in%colnames(aff_table_cisbp)]

# escaper_affinity = aff_table_cisbp[P[P$class=='escaper','name'],]
# repressed_affinity = aff_table_cisbp[P[P$class=='repressed','name'],]
# inactive_affinity = aff_table_cisbp[P[P$class=='inactive','name'],]

# evsr_cisbp = wilcox_affinity(escaper_affinity, repressed_affinity, c('escaper', 'repressed'),tf_table_cisbp, id_vec)
# evsi_cisbp = wilcox_affinity(escaper_affinity, inactive_affinity, c('escaper', 'inactive'), tf_table_cisbp, id_vec)
# rvsi_cisbp = wilcox_affinity(repressed_affinity, inactive_affinity, c('repressed', 'inactive'), tf_table_cisbp, id_vec)
# write.table(evsr_cisbp[which(evsr_cisbp$p_adjust < 0.05),], sep='\t',row.names=F, file='escaper_vs_repressed_aff_cisbp.txt')
# write.table(evsi_cisbp[which(evsi_cisbp$p_adjust < 0.05),], sep='\t',row.names=F, file='escaper_vs_inactive_aff_cisbp.txt')
# write.table(rvsi_cisbp[which(rvsi_cisbp$p_adjust < 0.05),], sep='\t',row.names=F, file='repressed_vs_inactive_aff_cisbp.txt')


aff_table_jaspar = read.table('../raw_data/jaspar_affinity/seq_psam.dat')
tf_table_jaspar = read.table('../raw_data/tf_table.txt', sep='\t', row.names=1, stringsAsFactors=F)

colnames(tf_table_jaspar) = c('name', 'species', 'class', 'family')
tf_translation = read.table('../raw_data/tf_translation.txt', stringsAsFactors=F)

tf_translation$K562_fpm = fpm[tf_translation$gene_id]

tf_expression = ddply(tf_translation[,c('name','gene_id','K562_fpm')],.(name),
                     function(x, te){
                          name=x[1,1]
                          ens = which(te$ensembl_gene_id%in%x$gene_id)
                          if (length(ens) > 0){
                            tissues= min(te[ens,'tissues_expressed'])
                          } else {
                            tissues = NA
                          }
                          c(expression=min(x[,3]),
                            tissues_expressed=tissues)
                     }, te=tissues_expressed)
tf_table_jaspar$expression = NaN
tf_match = match(tf_expression$name, tf_table_jaspar$name)
tf_table_jaspar$expression[tf_match] = tf_expression$expression
tf_table_jaspar$tissues_expressed = NaN
tf_table_jaspar$tissues_expressed[tf_match] = tf_expression$tissues_expressed

id_vec = colnames(aff_table_jaspar) = gsub('.xml','', colnames(aff_table_jaspar))

escaper_affinity = aff_table_jaspar[P[P$class=='escaper','name'],]
repressed_affinity = aff_table_jaspar[P[P$class=='repressed','name'],]
inactive_affinity = aff_table_jaspar[P[P$class=='inactive','name'],]

evsr_jaspar = wilcox_affinity(escaper_affinity, repressed_affinity, c('escaper', 'repressed'), tf_table_jaspar, id_vec)
evsi_jaspar = wilcox_affinity(escaper_affinity, inactive_affinity, c('escaper', 'inactive'), tf_table_jaspar, id_vec)
rvsi_jaspar = wilcox_affinity(repressed_affinity, inactive_affinity, c('repressed', 'inactive'), tf_table_jaspar, id_vec)
write.table(evsr_jaspar, sep='\t',row.names=F, file='escaper_vs_repressed_aff_jaspar.txt')
write.table(evsi_jaspar, sep='\t',row.names=F, file='escaper_vs_inactive_aff_jaspar.txt')
write.table(rvsi_jaspar, sep='\t',row.names=F, file='repressed_vs_inactive_aff_jaspar.txt')

ggplot(evsr_jaspar[evsr_jaspar$p_adjust<0.05, ], aes(x=log(mean_fc), y=tissues_expressed)) +
  geom_point(size=0.5, alpha=0.5) + 
  ggtitle('escaper vs repressed\np.adjusted < 0.05')

ggplot(evsr_jaspar[which(evsr_jaspar$p_adjust<0.05 & !is.na(evsr_jaspar$tissues_expressed)), ],
       aes(x=direction, color=direction, y=tissues_expressed)) + 
  geom_violin() + 
  geom_point(position=position_jitter(width=0.6), size=0.3,alpha=0.5) + 
  scale_color_manual(values=COL)

ggplot(rvsi_jaspar[rvsi_jaspar$p_adjust<0.05, ], aes(x=log(mean_fc), y=tissues_expressed)) +
  geom_point(size=0.5, alpha=0.5) + 
  ggtitle('repressed vs inactive\np.adjusted < 0.05')

ggplot(rvsi_jaspar[which(rvsi_jaspar$p_adjust<0.05 & !is.na(rvsi_jaspar$tissues_expressed)), ],
       aes(x=direction, color=direction, y=tissues_expressed)) + 
  geom_violin() + 
  geom_point(position=position_jitter(width=0.6), size=0.3,alpha=0.5) + 
  scale_color_manual(values=COL)

ggplot(evsr_jaspar[evsr_jaspar$p_adjust<0.05, ], aes(x=log(mean_fc), y=expression)) +
  geom_point(size=0.5, alpha=0.5) + 
  ggtitle('escaper vs repressed\np.adjusted < 0.05')

ggplot(evsr_jaspar[which(evsr_jaspar$p_adjust<0.05 & !is.na(evsr_jaspar$expression)), ],
       aes(x=direction, color=direction, y=expression)) + 
  geom_violin() + 
  geom_point(position=position_jitter(width=0.6), size=0.3,alpha=0.5) + 
  scale_color_manual(values=COL)

ggplot(rvsi_jaspar[rvsi_jaspar$p_adjust<0.05, ], aes(x=log(mean_fc), y=expression)) +
  geom_point(size=0.5, alpha=0.5) + 
  ggtitle('repressed vs inactive\np.adjusted < 0.05')

ggplot(rvsi_jaspar[which(rvsi_jaspar$p_adjust<0.05 & !is.na(rvsi_jaspar$expression)), ],
       aes(x=direction, color=direction, y=expression)) + 
  geom_violin() + 
  geom_point(position=position_jitter(width=0.6), size=0.3,alpha=0.5) + 
  scale_color_manual(values=COL)

rvsi_jaspar[which(rvsi_jaspar$tissues_expressed>1500 &
                  log(rvsi_jaspar$mean_fc)< -1.5 &
                  rvsi_jaspar$p_adjust < 0.01 &
                  rvsi_jaspar$expression > 0),'name']


aff_table_jaspar = read.table('../raw_data/jaspar_affinity_0.001/seq_psam_thr.dat')
tf_table_jaspar = read.table('../raw_data/tf_table.txt', sep='\t', row.names=1, stringsAsFactors=F)

colnames(tf_table_jaspar) = c('name', 'species', 'class', 'family')
tf_translation = read.table('../raw_data/tf_translation.txt', stringsAsFactors=F)

tf_translation$K562_fpm = fpm[tf_translation$gene_id]

tf_expression = ddply(tf_translation[,c('name','gene_id','K562_fpm')],.(name),
                     function(x, te){
                          name=x[1,1]
                          ens = which(te$ensembl_gene_id%in%x$gene_id)
                          if (length(ens) > 0){
                            tissues= min(te[ens,'tissues_expressed'])
                          } else {
                            tissues = NA
                          }
                          c(expression=min(x[,3]),
                            tissues_expressed=tissues)
                     }, te=tissues_expressed)

tf_table_jaspar$expression = NaN
tf_match = match(tf_expression$name, tf_table_jaspar$name)
tf_table_jaspar$expression[tf_match] = tf_expression$expression

tf_table_jaspar$tissues_expressed = NaN
tf_table_jaspar$tissues_expressed[tf_match] = tf_expression$tissues_expressed

id_vec = colnames(aff_table_jaspar) = gsub('.xml','', colnames(aff_table_jaspar))

escaper_affinity = aff_table_jaspar[P[P$class=='escaper','name'],]
repressed_affinity = aff_table_jaspar[P[P$class=='repressed','name'],]
inactive_affinity = aff_table_jaspar[P[P$class=='inactive','name'],]

evsr_jaspar = wilcox_affinity(escaper_affinity, repressed_affinity, tf_table_jaspar, id_vec)
evsi_jaspar = wilcox_affinity(escaper_affinity, inactive_affinity, tf_table_jaspar, id_vec)
rvsi_jaspar = wilcox_affinity(repressed_affinity, inactive_affinity, tf_table_jaspar, id_vec)
write.table(evsr_jaspar[which(evsr_jaspar$p_adjust < 0.05),], sep='\t',row.names=F, file='escaper_vs_repressed_aff_jaspar_0.001.txt')
write.table(evsi_jaspar[which(evsi_jaspar$p_adjust < 0.05),], sep='\t',row.names=F, file='escaper_vs_inactive_aff_jaspar_0.001.txt')
write.table(rvsi_jaspar[which(rvsi_jaspar$p_adjust < 0.05),], sep='\t',row.names=F, file='repressed_vs_inactive_aff_jaspar_0.001.txt')





aff_table_jaspar = read.table('../raw_data/jaspar_affinity_0.05/seq_psam_thr.dat')
tf_table_jaspar = read.table('../raw_data/tf_table.txt', sep='\t', row.names=1, stringsAsFactors=F)

colnames(tf_table_jaspar) = c('name', 'species', 'class', 'family')
tf_translation = read.table('../raw_data/tf_translation.txt', stringsAsFactors=F)

tf_translation$K562_fpm = fpm[tf_translation$gene_id]

tf_expression = ddply(tf_translation[,c('name','K562_fpm')],.(name),
                     function(x){
                          name=x[1,1]
                          c(expression=min(x[,2]))
                     })
tf_table_jaspar$expression = NaN
tf_match = match(tf_expression$name, tf_table_jaspar$name)
tf_table_jaspar$expression[tf_match] = tf_expression$expression

id_vec = colnames(aff_table_jaspar) = gsub('.xml','', colnames(aff_table_jaspar))

escaper_affinity = aff_table_jaspar[P[P$class=='escaper','name'],]
repressed_affinity = aff_table_jaspar[P[P$class=='repressed','name'],]
inactive_affinity = aff_table_jaspar[P[P$class=='inactive','name'],]

evsr_jaspar = wilcox_affinity(escaper_affinity, repressed_affinity, tf_table_jaspar, id_vec)
evsi_jaspar = wilcox_affinity(escaper_affinity, inactive_affinity, tf_table_jaspar, id_vec)
rvsi_jaspar = wilcox_affinity(repressed_affinity, inactive_affinity, tf_table_jaspar, id_vec)
write.table(evsr_jaspar[which(evsr_jaspar$p_adjust < 0.05),], sep='\t',row.names=F, file='escaper_vs_repressed_aff_jaspar_0.05.txt')
write.table(evsi_jaspar[which(evsi_jaspar$p_adjust < 0.05),], sep='\t',row.names=F, file='escaper_vs_inactive_aff_jaspar_0.05.txt')
write.table(rvsi_jaspar[which(rvsi_jaspar$p_adjust < 0.05),], sep='\t',row.names=F, file='repressed_vs_inactive_aff_jaspar_0.05.txt')






aff_table_jaspar$class = NA
aff_table_jaspar[P$name, 'class'] = as.character(P$class)

significant = evsr_jaspar[which(evsr_jaspar$p_adjust < 0.05), ]
significant$signed_p = ifelse(significant$mean_fc < 1, log(significant$p_adjust), -log(significant$p_adjust))
significant = significant[order(significant$signed_p), ]
for (id in rownames(significant)){
  title = paste(id, tf_table_jaspar[id,])
  title = paste0(title, '\np_adj=', significant[id,'p_adjust'], '\nmean_fc=', significant[id,'mean_fc'], '; median_fc=', significant[id,'median_fc'])
  print(ggplot(aff_table_jaspar[aff_table_jaspar$class%in%names(COL),], aes_string(x='class', y=paste0('log10(',id,')'), color='class')) + 
    geom_violin() +
    ggtitle(title) +
    geom_point(position=position_jitter(width=0.5), alpha=0.3, size=0.3) +
    scale_color_manual(values=COL))
}



aff_table_jaspar_sub = read.table('../raw_data/jaspar_affinity_substr/seq_psam.dat')
ens = gsub('_[0-9]+:[0-9]+','', rownames(aff_table_jaspar_sub))
aff_table_jaspar_sub$class = NA
ens_match = match(ens, P$name)
aff_table_jaspar_sub$class = P[ens_match, 'class']
colnames(aff_table_jaspar_sub) = gsub('.xml','', colnames(aff_table_jaspar_sub))
e_id = rownames(significant)[significant$signed_p > 0]
e_id = e_id[length(e_id):1]
for (ida in e_id[1:(length(e_id)-1)]){
  titlea = paste(ida, tf_table_jaspar[ida,])
  for (idb in e_id[(which(e_id==ida)+1):length(e_id)]){
    titleb = paste(idb, tf_table_jaspar[idb,])
    print(ggplot(aff_table_jaspar_sub[aff_table_jaspar_sub$class%in%names(COL),], aes_string(x=paste0('log10(',ida,')'), y=paste0('log10(',idb,')'), color='class')) + 
    ggtitle(paste0(titlea, '\n', titleb)) +
    geom_point(alpha=0.3, size=0.3) +
    geom_smooth() +
    scale_color_manual(values=COL))
  }
}


ggplot(aff_table_jaspar[aff_table_jaspar$class%in%names(COL),], aes(x=class, y=log10(MA0605.1), color=class)) + 
  geom_violin() +
  geom_point(position=position_jitter(width=0.5), alpha=0.3, size=0.3) +
  scale_color_manual(values=COL)


fit_evsr = mclapply(id_vec, function(id){
    x = escaper_affinity[,id]
    y = repressed_affinity[,id]
    mean = c(mean(x), mean(y))
    direction = c('escaper', 'repressed')[which(mean==max(mean))]
    if (length(direction) == 2){
      direction = 'unchanged'
    }
    median_fc = median(x) / median(y)
    mean_fc = mean[1] / mean[2]
    w = wilcox.test(x, y)
    return(list(w,direction, median_fc, mean_fc))
  })

p_vec = unlist(lapply(fit_evsr, function(x){ x[[1]]$p.value}))
p_adjust = p.adjust(p_vec, method='fdr')
direction = lapply(fit_evsr, function(x){ x[[2]]})
median_fc =  lapply(fit_evsr, function(x){ x[[3]]})
mean_fc =  lapply(fit_evsr, function(x){ x[[4]]})

plot_frame = data.frame(min_log_p=-log(p_vec), 
                        log_mean_fc = log(unlist(median_fc)))
ggplot(plot_frame, aes(x=log_mean_fc, y=min_log_p)) + 
  geom_point(alpha=0.5,size=0.5) +
  geom_point(data=plot_frame[which(p_adjust<0.05), ], color='red', size=0.5) 

significant = which(p_adjust<0.05)
evsr_table = cbind(id=id_vec[significant], 
                   tf_table[match(id_vec[significant], tf_table$Motif_ID), ],
                   direction=unlist(direction[significant]),
                   p_adjusted = p_adjust[significant],
                   median_fc = unlist(median_fc[significant]),
                   mean_fc = unlist(mean_fc[significant]))
# evsr_table = cbind(id=id_vec, 
#                    tf_table[id_vec, ],
#                    direction=unlist(direction),
#                    p_adjusted = p_adjust,
#                    fold_change = unlist(fc))
write.table(evsr_table, sep='\t',row.names=F, file='escaper_vs_repressed_aff_cisbp.txt')

fit_evsi = mclapply(id_vec, function(id){
    x = escaper_affinity[,id]
    y = inactive_affinity[,id]
    mean = c(mean(x), mean(y))
    direction = c('escaper', 'inactive')[which(mean==max(mean))]
    fc = mean[1] / mean[2]
    w = wilcox.test(x, y)
    return(list(w,direction, fc))
  })

p_vec = unlist(lapply(fit_evsi, function(x){ x[[1]]$p.value}))
p_adjust = p.adjust(p_vec)
direction = lapply(fit_evsi, function(x){ x[[2]]})
fc =  lapply(fit_evsi, function(x){ x[[3]]})

significant = which(p_adjust<0.05)

evsi_table = cbind(id=id_vec[significant], 
                   tf_table[id_vec[significant], ],
                   direction=unlist(direction[significant]),
                   p_adjusted = p_adjust[significant],
                   fold_change = unlist(fc[significant]))
write.table(evsi_table, sep='\t',row.names=F, file='escaper_vs_inactive_aff.txt')

fit_rvsi = mclapply(id_vec, function(id){
    x = repressed_affinity[,id]
    y = inactive_affinity[,id]
    mean = c(mean(x), mean(y))
    direction = c('repressed', 'inactive')[which(mean==max(mean))]
    fc = mean[1] / mean[2]
    w = wilcox.test(x, y)
    return(list(w,direction, fc))
  })

p_vec = unlist(lapply(fit_rvsi, function(x){ x[[1]]$p.value}))
p_adjust = p.adjust(p_vec)
direction = lapply(fit_rvsi, function(x){ x[[2]]})
fc =  lapply(fit_rvsi, function(x){ x[[3]]})

significant = which(p_adjust<0.05)

rvsi_table = cbind(id=id_vec[significant], 
                   tf_table[id_vec[significant], ],
                   direction=unlist(direction[significant]),
                   p_adjusted = p_adjust[significant],
                   fold_change = unlist(fc[significant]))
write.table(rvsi_table, sep='\t',row.names=F, file='repressed_vs_inactive_aff.txt')

all_prom = getSeq(Hsapiens, TSSR_gr)
n_freq = oligonucleotideFrequency(all_prom, width=1)
P$GC_content = (n_freq[,'A'] + n_freq[,'G'])/rowSums(n_freq)

top_table = cbind(name = c("(Intercept)", 'GC_content', 'CpG_class'),
                  species = rep("-", 3),
                  class = rep("-", 3), 
                  family=rep("-", 3))
rownames(top_table) = top_table[,'name']

tf_table = rbind.data.frame(top_table, tf_table)

p_evsr = P[which(P$class %in% c('escaper', 'repressed')),]
x = cbind(GC_content=p_evsr$GC_content,
          CpG_class=p_evsr$cpg_class=='CpG',
          aff_table[p_evsr$name, ])

y = p_evsr$class == 'escaper'
cvfit_evsr = cv.glmnet(as.matrix(x),y, family='binomial', parallel=T)
coef_evsr = coef(cvfit_evsr, s='lambda.1se')
coef_evsr_nn = coef_evsr[coef_evsr[,1]!=0, ]
evsr_enet_table = cbind(id=names(coef_evsr_nn),
                        tf_table[names(coef_evsr_nn), ],
                        coef_evsr_nn)

write.table(evsr_enet_table, sep='\t',row.names=F, file='escaper_vs_repressed_enet.txt')


p_evsi = P[which(P$class %in% c('escaper', 'inactive')),]
x = cbind(GC_content=p_evsi$GC_content,
          CpG_class=p_evsi$cpg_class=='CpG',
          aff_table[p_evsi$name, rownames(tf_table)[which(tf_table$expression>0)]])

y = p_evsi$class == 'escaper'
cvfit_evsi = cv.glmnet(as.matrix(x),y, family='binomial', parallel=T)
coef_evsi = coef(cvfit_evsi, s='lambda.1se')
coef_evsi_nn = coef_evsi[coef_evsi[,1]!=0, ]
evsi_enet_table = cbind(id=names(coef_evsi_nn),
                        tf_table[names(coef_evsi_nn), ],
                        coef_evsi_nn)
write.table(evsi_enet_table, sep='\t',row.names=F, file='escaper_vs_inactive_enet.txt')

p_rvsi = P[which(P$class %in% c('repressed', 'inactive')),]
x = cbind(GC_content=p_rvsi$GC_content,
          CpG_class=p_rvsi$cpg_class=='CpG',
          aff_table[p_rvsi$name, ])

y = p_rvsi$class == 'repressed'
cvfit_rvsi = cv.glmnet(as.matrix(x),y, family='binomial', parallel=T)
coef_rvsi = coef(cvfit_rvsi, s='lambda.1se')
coef_rvsi_nn = coef_rvsi[coef_rvsi[,1]!=0, ]
rvsi_enet_table = cbind(id=names(coef_rvsi_nn),
                        tf_table[names(coef_rvsi_nn), ],
                        coef_rvsi_nn)
write.table(rvsi_enet_table, sep='\t',row.names=F, file='repressed_vs_inactive_enet.txt')

save(cvfit_evsr, cvfit_evsi, cvfit_rvsi, file='cvfit_rvsi.rda')


id_vec = unlist(lapply(jaspar_list, function(x){x$ID}))

name_vec = unlist(lapply(jaspar_list, function(x){x$name}))
names(name_vec) = id_vec



# aff_matrix = matrix(0, nrow=nrow(P), ncol=length(id_vec), dimnames=list(P$name, id_vec))
# aff_table = read.table('tssr_1000_100_fimo_sum.txt.gz')

# j_vec = match(aff_table[,1], colnames(aff_matrix))
# i_vec = match(aff_table[,2], rownames(aff_matrix))
# aff_matrix[cbind(i_vec,j_vec)] = aff_table[,3]

# y = as.matrix(P[P$LAD==1,c('SuRE', 'GROcap')])
# x = aff_matrix[P$LAD==1, ]
# cvmfit = cv.glmnet(x,y,family='mgaussian')

# x[x>0] = 1

# cvmfit = cv.glmnet(x,y,family='multinomial')

# cvfit = cv.glmnet(x,P$LRS[P$LAD==1], family='gaussian')

# cvfit_esc = cv.glmnet(x,(P$class=='escaper')[P$LAD==1], family='binomial')


# annot_table = read.table('../raw_data/jaspar/annotation.txt',sep='\t', stringsAsFactors=F)
# annot_table = annot_table[annot_table[,1]%in% gsub('[.][0-9]','', id_vec), ]


seqs.ms = ms(as.character(all_prom))
names(seqs.ms)=P$name
mm_all_prom = build.mm(seqs.ms, order = 0)

score_motif <- function(motif, ms, mm){
  id = motif$ID
  pwm = motif$profileMatrix
  score = score.ms(ms, pwm, mm=mm, threshold=0)
  score$name = names(names(ms))[match(score$seqname, names(ms))]
  return(score)
}

count_score <- function(score, P){
  result = matrix(0, nrow = nrow(P), ncol=2, 
                  dimnames=list(P$name, c('count', 'sum_likelihood')))
  count = table(score$name)
  result[names(count),'count'] = count
  sum_lh = ddply(score,.(name),function(x){sum(x$score)})
  result[sum_lh$name, 'sum_likelihood'] = sum_lh[,2]
  return(result)
}


score_list = mclapply(jaspar_list, score_motif, 
                      ms=seqs.ms[P$LAD==1], mm=mm_all_prom, mc.cores=10)

prom_score_list = mclapply(score_list, count_score, 
                           P=P[P$LAD==1, ], mc.cores=10)

count_matrix = do.call(cbind, lapply(prom_score_list,function(x){as.numeric(x[,'count'])}))
sum_likelihood_matrix = do.call(cbind, lapply(prom_score_list,function(x){as.numeric(x[,'sum_likelihood'])}))
rownames(count_matrix) = rownames(sum_likelihood_matrix) = P$name[P$LAD==1]
colnames(count_matrix) = colnames(sum_likelihood_matrix) = id_vec

escaper_likelyhood = sum_likelihood_matrix[P[P$class=='escaper','name'],]
repressed_likelyhood = sum_likelihood_matrix[P[P$class=='repressed','name'],]
inactive_likelyhood = sum_likelihood_matrix[P[P$class=='inactive','name'],]

plot(density(escaper_likelyhood[,'MA0641.1']))


fit_evsr = mclapply(id_vec, function(id){
    x = escaper_likelyhood[,id]
    y = repressed_likelyhood[,id]
    mean = c(mean(x), mean(y))
    direction = c('escaper', 'repressed')[which(mean==max(mean))]
    fc = mean[1] / mean[2]
    w = wilcox.test(x, y)
    return(list(w,direction, fc))
  })

p_vec = unlist(lapply(fit_evsr, function(x){ x[[1]]$p.value}))
p_adjust = p.adjust(p_vec)
direction = unlist(lapply(fit_evsr, function(x){ x[[2]]}))
fc =  unlist(lapply(fit_evsr, function(x){ x[[3]]}))

significant = names(p_adjust[which(p_adjust<0.05)])
evsr_table = cbind(id=id_vec[significant], 
                   tf_table[id_vec[significant], ],
                   direction=direction[significant],
                   p_adjusted = p_adjust[significant],
                   fold_change = fc[significant])
write.table(evsr_table, sep='\t',row.names=F, file='escaper_vs_repressed_table.txt')

fit_evsi = mclapply(id_vec, function(id){
    x = escaper_likelyhood[,id]
    y = inactive_likelyhood[,id]
    mean = c(mean(x), mean(y))
    direction = c('escaper', 'inactive')[which(mean==max(mean))]
    fc = mean[1] / mean[2]
    w = wilcox.test(x, y)
    return(list(w,direction, fc))
  })

p_vec = unlist(lapply(fit_evsi, function(x){ x[[1]]$p.value}))
p_adjust = p.adjust(p_vec)
direction = unlist(lapply(fit_evsi, function(x){ x[[2]]}))
fc =  unlist(lapply(fit_evsi, function(x){ x[[3]]}))

significant = names(p_adjust[which(p_adjust<0.05)])

evsi_table = cbind(id=id_vec[significant], 
                   tf_table[id_vec[significant], ],
                   direction=direction[significant],
                   p_adjusted = p_adjust[significant],
                   fold_change = fc[significant])
write.table(evsi_table, sep='\t',row.names=F, file='escaper_vs_inactive_table.txt')

fit_rvsi = mclapply(id_vec, function(id){
    x = repressed_likelyhood[,id]
    y = inactive_likelyhood[,id]
    mean = c(mean(x), mean(y))
    direction = c('repressed', 'inactive')[which(mean==max(mean))]
    fc = mean[1] / mean[2]
    w = wilcox.test(x, y)
    return(list(w,direction, fc))
  })

p_vec = unlist(lapply(fit_rvsi, function(x){ x[[1]]$p.value}))
p_adjust = p.adjust(p_vec)
direction = unlist(lapply(fit_rvsi, function(x){ x[[2]]}))
fc =  unlist(lapply(fit_rvsi, function(x){ x[[3]]}))

significant = names(p_adjust[which(p_adjust<0.05)])

rvsi_table = cbind(id=id_vec[significant], 
                   tf_table[id_vec[significant], ],
                   direction=direction[significant],
                   p_adjusted = p_adjust[significant],
                   fold_change = fc[significant])
write.table(rvsi_table, sep='\t',row.names=F, file='repressed_vs_inactive_table.txt')

top_table = cbind(name = c("(Intercept)", 'GC_content', 'CpG_class'),
                  species = rep("-", 3),
                  class = rep("-", 3), 
                  family=rep("-", 3))
rownames(top_table) = top_table[,'name']

tf_table = rbind.data.frame(top_table, tf_table)

p_evsr = P[which(P$class %in% c('escaper', 'repressed')),]
x = cbind(GC_content=p_evsr$GC_content,
          CpG_class=p_evsr$cpg_class=='CpG',
          sum_likelihood_matrix[p_evsr$name, ])

y = p_evsr$class == 'escaper'
cvfit_evsr = cv.glmnet(x,y, family='binomial', parallel=T)
coef_evsr = coef(cvfit_evsr, s='lambda.1se')
coef_evsr_nn = coef_evsr[coef_evsr[,1]!=0, ]
evsr_enet_table = cbind(id=names(coef_evsr_nn),
                        tf_table[names(coef_evsr_nn), ],
                        coef_evsr_nn)
write.table(evsr_enet_table, sep='\t',row.names=F, file='escaper_vs_repressed_enet.txt')


p_evsi = P[which(P$class %in% c('escaper', 'inactive')),]
x = cbind(GC_content=p_evsi$GC_content,
          CpG_class=p_evsi$cpg_class=='CpG',
          sum_likelihood_matrix[p_evsi$name, ])

y = p_evsi$class == 'escaper'
cvfit_evsi = cv.glmnet(x,y, family='binomial', parallel=T)
coef_evsi = coef(cvfit_evsi, s='lambda.1se')
coef_evsi_nn = coef_evsi[coef_evsi[,1]!=0, ]
evsi_enet_table = cbind(id=names(coef_evsi_nn),
                        tf_table[names(coef_evsi_nn), ],
                        coef_evsi_nn)
write.table(evsi_enet_table, sep='\t',row.names=F, file='escaper_vs_inactive_enet.txt')

p_rvsi = P[which(P$class %in% c('repressed', 'inactive')),]
x = cbind(GC_content=p_rvsi$GC_content,
          CpG_class=p_rvsi$cpg_class=='CpG',
          sum_likelihood_matrix[p_rvsi$name, ])

y = p_rvsi$class == 'repressed'
cvfit_rvsi = cv.glmnet(x,y, family='binomial', parallel=T)
coef_rvsi = coef(cvfit_rvsi, s='lambda.1se')
coef_rvsi_nn = coef_rvsi[coef_rvsi[,1]!=0, ]
rvsi_enet_table = cbind(id=names(coef_rvsi_nn),
                        tf_table[names(coef_rvsi_nn), ],
                        coef_rvsi_nn)
write.table(rvsi_enet_table, sep='\t',row.names=F, file='repressed_vs_inactive_enet.txt')

save(cvfit_evsr, cvfit_evsi, cvfit_rvsi, file='cvfit_rvsi.rda')


# aff_matrix = vapply(p_string_set[1:10], function(bio_string){
#           vapply(jaspar_list, function(motif){
#               id = motif$ID
#               pwm = motif$profileMatrix

#               start_range = 1:(width(TSSR_gr[1])-ncol(pwm)+1)
#               sum_score = sum(PWMscoreStartingAt(pwm, bio_string, starting.at=start_range))
#               return(sum_score)
#             }, 0)
#           }, vector(length=length(jaspar_list), mode='double'))
```

```{r}
lad_gr = import.bed('../../../data/tracks/hg19/cl20161019_LAD_continuous_2state_K562.bed')
ilad_gr = lad_gr[lad_gr$name == 'interLAD']
o = findOverlaps(ilad_gr, tss_gr)
o_frame = data.frame(o)
o_frame$gene_id = P[subjectHits(o), 'ensembl_gene_id']
o_frame$tss = P[subjectHits(o), 'tss']
o_frame = ddply(o_frame, .(queryHits),
      function(x){
        ens_border = c(x$gene_id[which(x$tss==min(x$tss))],
                       x$gene_id[which(x$tss==max(x$tss))])
        x$iLAD_class = 'middle_gene'
        x[which(x$gene_id%in%ens_border), 'iLAD_class'] = 'edge_gene'
        return(x)
      })
P$iLAD_class = NA
P[o_frame$subjectHits, 'iLAD_class'] = o_frame$iLAD_class

p_high = P[P$GROcap > 0, ]

score_list = mclapply(jaspar_list, score_motif, 
                      ms=seqs.ms[P$name%in%p_high$name], P=p_high, mm=mm_all_prom, mc.cores=10)
count_matrix = do.call(cbind, lapply(score_list,function(x){as.numeric(x[,'count'])}))
sum_likelihood_matrix = do.call(cbind, lapply(score_list,function(x){as.numeric(x[,'sum_likelihood'])}))
rownames(count_matrix) = rownames(sum_likelihood_matrix) = p_high$name
colnames(count_matrix) = colnames(sum_likelihood_matrix) = id_vec


p_ilad = p_high
edge_likelyhood = sum_likelihood_matrix[p_ilad[which(p_ilad$iLAD_class=='edge_gene'),'name'],]
middle_likelyhood = sum_likelihood_matrix[p_ilad[which(p_ilad$iLAD_class=='middle_gene'),'name'],]

fit_ilad = mclapply(id_vec, function(id){
    x = edge_likelyhood[,id]
    y = middle_likelyhood[,id]
    mean = c(mean(x), mean(y))
    direction = c('edge', 'middle')[which(mean==max(mean))]
    fc = mean[1] / mean[2]
    w = wilcox.test(x, y)
    return(list(w,direction, fc))
  })

p_vec = unlist(lapply(fit_ilad, function(x){ x[[1]]$p.value}))
p_adjust = p.adjust(p_vec)
direction = unlist(lapply(fit_ilad, function(x){ x[[2]]}))
fc =  unlist(lapply(fit_ilad, function(x){ x[[3]]}))

significant = names(p_adjust[which(p_adjust<0.05)])
ilad_table = cbind(id=id_vec[significant], 
                   tf_table[id_vec[significant], ],
                   direction=direction[significant],
                   p_adjusted = p_adjust[significant])
write.table(ilad_table, sep='\t',row.names=F, file='edge_vs_middle_iLAD_table.txt')

p_ilad = p_ilad[p_ilad$iLAD_class%in%c('edge_gene', 'middle_gene'), ]
x = cbind(GC_content=p_ilad$GC_content,
          CpG_class=p_ilad$cpg_class=='CpG',
          sum_likelihood_matrix[p_ilad$name, ])

y = p_ilad$iLAD_class == 'edge_gene'
cvfit_ilad = cv.glmnet(x,y, family='binomial', parallel=T)
coef_ilad = coef(cvfit_ilad, s='lambda.1se')
coef_ilad_nn = coef_ilad[coef_ilad[,1]!=0, ]
ilad_enet_table = cbind(id=names(coef_ilad_nn),
                        tf_table[names(coef_ilad_nn), ],
                        coef_ilad_nn)
write.table(ilad_enet_table, sep='\t',row.names=F, file='edge_vs_middle_iLAD_enet.txt')


```

```r
library(BSgenome)
library(BSgenome.Hsapiens.UCSC.hg19)
.processJASPARText <- function(text){
  ID <- sub("^>", "", strsplit(text[1], "\t")[[1]][1])
  name <- strsplit(text[1], "\t")[[1]][2]
  if(!identical(substr(text[2:5], 1, 1), DNA_BASES)){
    stop("The second to fifth lines of the file must start with",
         "`A`, `C`, `G`, `T`, respectively.")
  }
  profileMatrix <- do.call(rbind, strsplit(sub(" *]$", "", 
                                               sub("^(A|C|G|T)  \\[ *", "",
                                                   text[2:5])), " +"))
  mode(profileMatrix) <- "integer"
  rownames(profileMatrix) <- DNA_BASES
  ## changed the following part:
  # ans <- PFMatrix(ID=ID, name=name, profileMatrix=profileMatrix)
  pwm = t(t(profileMatrix)/colSums(profileMatrix))
  ans <- list(ID=ID, name=name, profileMatrix=pwm)
}

readJASPARMatrix <- function(fn, type=c("individual", "all")){
  type <- match.arg(type)
  text <- readLines(fn)
  if(type == "individual"){
    if(length(text) != 5L){
      stop("The `individual` format is supposed to have 5 lines!")
    }
    ans <- .processJASPARText(text)
  }else{
    if(length(text) %% 6 != 0L){
      stop("The `all` format is supposed to have a number of lines",
           "mutipled by 6!")
    }
    text2 <- split(text, rep(1:(length(text)/6), rep(6, length(text)/6)))
    ans <- lapply(text2, .processJASPARText)
    # ans <- do.call(PFMatrixList, ans)
  }
  return(ans)
}
load("../raw_data/gencode.sure.160617.rda")
Prom<-gencode.sure.160617; rm(gencode.sure.160617) #simpler name
#first re-calculate pseudocounts without jitter
P<-Prom[,c(1:8,23,20,26,28, 27)] #SuRE, GRO-cap, CAGE and LAD columns only
names(P)[9:13]<-c("SuRE", "GROcap", "CAGE", "LAD", 'tissues_expressed')
gene_gr <-makeGRangesFromDataFrame(data.frame(seqnames=P$chr,
                                              start=P$txStart,
                                              end=P$txEnd,
                                              strand=P$strand,
                                              tss=P$tss,
                                              name=P$name),
                                              keep.extra.columns=TRUE)

jaspar_list = readJASPARMatrix('../raw_data/JASPAR_pfm_vertabrates_non_redundant.txt', 'all')


get_aff_matrix <- function(tss_up, tss_down, gene_gr, P, jaspar_list){
  TSSR_gr = gene_gr
  P_start = P$tss - ifelse(P$strand=='+',tss_down,tss_up)
  P_start = ifelse(P_start<1,1,P_start)
  P_end = P$tss + ifelse(P$strand=='+',tss_up,tss_down)
  ranges(TSSR_gr) = IRanges(P_start, P_end)

  p_string_set = getSeq(Hsapiens, TSSR_gr)
  aff_matrix = mclapply(p_string_set, function(bio_string){
            vapply(jaspar_list, function(motif){
                id = motif$ID
                pwm = motif$profileMatrix
                min_pwm = reverseComplement(pwm)
                start_range = 1:(width(TSSR_gr[1])-ncol(pwm)+1)
                sum_score = sum(PWMscoreStartingAt(pwm, bio_string, starting.at=start_range),
                                PWMscoreStartingAt(min_pwm, bio_string, starting.at=start_range))
                return(sum_score)
              }, 0)
            }, mc.cores=5)
  return(aff_matrix)
}

aff_matrix = get_aff_matrix(500, 50, gene_gr, P, jaspar_list)
save(aff_matrix, '../raw_data/aff_matrix_500_50.rdata')

aff_matrix = get_aff_matrix(1000, 100, gene_gr, P, jaspar_list)
save(aff_matrix, '../raw_data/aff_matrix_1000_100.rdata')

aff_matrix = get_aff_matrix(2000, 100, gene_gr, P, jaspar_list)
save(aff_matrix, '../raw_data/aff_matrix_2000_100.rdata')

```


```
/home/NFS/users/j.yanez/utils/meme/bin/fimo \
  --text \
  ~/data/motif_databases/JASPAR/JASPAR_CORE_2016_vertebrates.meme \
  workspace/tssr_1000_100.fa | \
  gzip -c > workspace/tssr_1000_100_fimo.txt.gz

gunzip -c workspace/tssr_1000_100_fimo.txt.gz | \
  awk '{
    if(NR==1){
      pat = $1
      name = $2
      score = $6
    } else {
      if (pat==$1 && name==$2){
        score += $6
      } else {
        print pat"\t"name"\t"score
        pat = $1
        name = $2
        score = $6
      }
    }
  }END{
    print pat"\t"name"\t"score 
  }' | gzip -c > workspace/tssr_1000_100_fimo_sum.txt.gz

```



```

awk -F"\t" '{
  if (NR==FNR && $2=="CORE"){
    a[$1] = $3
  } else if (NR==1){
    id = $1
    class = $2
  } else if (id==$1) {
    if ($2=="family"){
      fam=$3
    } else if ($2=="type"){
      type=$3
    } else if ($2=="class"){
      class=$3
    }
  } else {
    if (id in a){
      print a[id]"\t"id"\t"class"\t"type"\t"fam
    }
    id = $1
    class = $3
    fam=""
    type=""
  }
}' MATRIX.txt MATRIX_ANNOTATION.txt > annotation.txt

```

```{r}

## let's look at one of the trypthophan clusters.
hist(count_matrix[P[P$class=='escaper','name'],'MA0641.1'])
hist(count_matrix[P[P$class=='repressed','name'],'MA0641.1'])
hist(count_matrix[P[P$class=='inactive','name'],'MA0641.1'])

```


awk '{
  if ($1 ~ /^>/){
    title=$1; gsub(">", "", title)
  } 
  print $0 > title".pwm"
}' /media/HPC_Home/projects/single_cell_damid/raw_data/JASPAR_pfm_vertabrates_non_redundant.txt 

for f in $(ls PWMs/Jaspar-Core16/)
do
  name="${f%.*}"
  title=$(head -n1 PWMs/Jaspar-Core16/$f | sed 's/>//' | sed 's/[[:space:]]/_/')
  echo $title >> PSAMs/Jaspar_2016.list
  Convert2PSAM -source=ja -inp=$REDUCE_SUITE/data/formats/jaspar_ex2.dat \
               -infFile=PWMs/Jaspar-Core16/$f -psam=PSAMs/Jaspar_2016/$name.xml
done



for f in $(ls PWMs/Cis-BP_2017/pwms_all_motifs/)
do
  tail -n+2 PWMs/Cis-BP_2017/pwms_all_motifs/$f | \
    awk '{
      if (NR==1){
        A=$2
        C=$3
        G=$4
        T=$5
      } else {
        A=A"\t"$2
        C=C"\t"$3
        G=G"\t"$4
        T=T"\t"$5
      }
    }END{
      print A
      print C
      print G
      print T
    }' > PWMs/Cis-BP_2017/pwms_jaspar/$f
done

for f in $(ls PWMs/Cis-BP_2017/pwms_jaspar/)
do
  name="${f%.*}"
  title=$(head -n1 PWMs/Cis-BP_2017/pwms_jaspar/$f | sed 's/>//' | sed 's/[[:space:]]/_/')
  Convert2PSAM -source=ja -infFile=PWMs/Cis-BP_2017/pwms_jaspar/$f -psam=PSAMs/Cis-BP_2017/$name.xml
done



Convert2PSAM \
        -source=jaspar \
        -inpfile=M0188_1.02.txt \
        -psamfile=M0188_1.02.xml

<psam>
# A            C            G            T             # no. opt  
# +============+============+============+============ # ==+===+==
  1            0.19398      0.554327     0.00247875    #   1   A  
  0.249075     0.212248     0.0934807    1             #   2   T  
  0.10435      1            0.118837     8.43952e-05   #   3   C  
  1            2.99845e-07  0.267135     0.138069      #   4   A  
  0.0441572    1            0.23457      0.346456      #   5   C  
  0.339596     0.657047     1            0.14808       #   6   G  
  0.316637     1            4.82073e-05  0.951229      #   7   Y  
  0.130029     0.40657      1            0.316637      #   8   G  
  1            0.170333     0.283654     0.343009      #   9   A  
</psam>
</matrix_reduce>





```python

with open('tssr_300_50_seg.fa', 'w') as f_out:
  with open('tssr_300_50.fa') as f_in:
    for line in f_in.readlines():
      if line.startswith('>'):
        name = line.strip()
      else:
        for i in range(0,320,30):
          sub = line[i:(i+30)]
          f_out.write(''.join((name,'_',str(i),':',str(i+30))))
          f_out.write('\n')
          f_out.write(sub)
          f_out.write('\n')

```

```
AffinityProfile -sequence=raw_data/tssr_300_50_seg.fa \
                -strand=2 \
                -psam_list=$REDUCE_SUITE/data/PSAMs/Jaspar_2016.list \
                -output=raw_data/jaspar_affinity_substr

```



```
awk '{
  if (NR==FNR){
    if ($5 ~ /^entrez/){
      gsub("entrezgene:", "", $5)
      entrez[$1] = $5
    }
  } else {
    if ($1 in entrez){
      num=0
      for(i = 2; i <= NF; i++){
        if ($i > 0){
          num++
        }
      }
      print entrez[$1]"\t"num
    }
  }
}' <(gunzip -c hg19.cage_peak_phase1and2combined_ann.txt.gz) <(gunzip -c hg19.cage_peak_phase1and2combined_counts.osc.txt.gz) | gzip -c > hg19.cage_peak_entrez_tissues_expressed.txt.gz


```


```r
library(biomaRt)
library(plyr)
tissue_count = read.table('hg19.cage_peak_entrez_tissues_expressed.txt.gz')
humanMart = useMart(biomart = 'ensembl', dataset = 'hsapiens_gene_ensembl')
bm_eg = getBM(attributes=c('ensembl_gene_id','entrezgene', 'hgnc_symbol'),
              filters='entrezgene', values=tissue_count[,1], mart=humanMart)


tissue_count = cbind(tissue_count, bm_eg[match(tissue_count[,1], bm_eg$entrezgene), ])
max_tissue = ddply(tissue_count[,c('ensembl_gene_id', 'entrezgene', 'hgnc_symbol', 'V2')],
                   .(ensembl_gene_id),
                   function(x){
                     if (!is.na(x[1,1])){
                       result = unlist(c(x[1,1:3], tissues_expressed=max(x[,4])))
                     } else {
                       result = unlist(c(x[1,1:3], tissues_expressed=NaN))
                    }
                    return(result)
              })
max_tissue$tissues_expressed = as.numeric(max_tissue$tissues_expressed)
write.table(max_tissue, 'max_tissues_expressed.txt', quote=F, row.names=F, sep='\t')
```




```{r}
library(XML)
parsePsam <- function(file_name){
  data = xmlToList(xmlParse(file_name))
  col_line = gsub('#.*', '', gsub('\n#', '', data$psam))
  data$psam = read.table(text=data$psam)
  colnames(data$psam) = read.table(text=col_line,colClasses='character')
  return(data)
}

reversePsam <- function(psam){
  reverse = psam[nrow(psam):1,4:1]
  dimnames(reverse) = dimnames(psam)
  return(reverse)
}

comparePsam <- function(psam1, psam2, x=0){
  n1 = nrow(psam2) - 1
  l_total = nrow(psam1) + nrow(psam2) + nrow(psam2) - 2
  n2 = l_total-nrow(psam2)
  corr = -Inf
  for (i in -n1:l_total){
    extra1a = matrix(1,ncol=4,nrow=ifelse(i<0, abs(i), 0), dimnames=list(NULL, colnames(psam1)))
    p1 = rbind(extra1a, psam1)
    extra2a = matrix(1,ncol=4,nrow=ifelse(i>0, i, 0), dimnames=list(NULL, colnames(psam1)))
    p2 = rbind(extra2a, psam2)
    r = nrow(p1) - nrow(p2)
    extra1b = matrix(1,ncol=4,nrow=ifelse(r<0, abs(r), 0), dimnames=list(NULL, colnames(psam1)))
    p1 = rbind(p1, extra1b)
    extra2b = matrix(1,ncol=4,nrow=ifelse(r>0, r, 0), dimnames=list(NULL, colnames(psam1)))
    p2 = rbind(p2, extra2b)
    corr = max(corr, cor(unlist(p1), unlist(p2), method='pearson'))
  }
  return(corr)
}

file_list = read.table('~/Programs/REDUCE_Suite/data/PSAMs/Jaspar_2016.list',
                       stringsAsFactors=F)[,1]
name_list = gsub('/.*/','',gsub('.xml','',file_list))

psam_list = lapply(file_list, parsePsam)

cor_list = mclapply(1:length(psam_list), function(x, psam_list){
                unlist(lapply(psam_list[x:length(psam_list)], function(y, psam1){
                      comparePsam(psam1, y$psam)
                    }, psam1 = psam_list[[x]]$psam))
              }, psam_list=psam_list, mc.cores=10)

```